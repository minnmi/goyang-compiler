

class FinalCode:

    #Construtor da classe com a lista de variáveis, strings e a lista 
    # de armazenamento do código.
    def __init__(self, variables = [], strings = {}, code = []):
        self.variables = variables
        self.strings = strings
        self.code = code
        self.plain_text = ""
    # arquvivos de saída
    def add_header(self):
        self.plain_text += "; Generated by goyangi Compiler.\n\n"
        self.plain_text += "; compile the program using commands like:\n"
        self.plain_text += ";\tfasm [output code].asm [output object].o"

    def add_format(self):
        self.plain_text += "\n\nformat ELF\n\n"

    def generate_declarations(self):
        self.plain_text += "\n\nsection '.data' writeable\n\n"

        for str_id, str_content in self.strings.items():
            fmt_str_id = str_id.ljust(10, " ")
            decl_end = (", 0xA" if str_id.startswith("str_") else "") + ", 0\n"
            self.plain_text += fmt_str_id + "\tdb\t" + str_content + decl_end

        for variable in self.variables:
            fmt_variable = variable.ljust(10, " ")
            self.plain_text += fmt_variable + "\tdd\t0\n"

    def code_header(self):
        self.plain_text += "\n\nsection '.text' executable\n\n"
        self.plain_text += "\tpublic main\n"
        self.plain_text += "\tmain:\n\n"

        self.plain_text += "\textrn printf\n"
        self.plain_text += "\textrn scanf\n"

    def code_tail(self):
        self.plain_text += "\tmov\tEAX, 1"
        self.plain_text += "\n\tXOR\tEBX, EBX"
        self.plain_text += "\n\tINT\t0x80"

    #Gerando o código.
    def generate_code(self):
        self.code_header()
        
        #For para verificar todas as instruções
        #Que estão no código
        for instruction in self.code:
            code = instruction[0]
            operands = instruction[1:]

            if code == "MOV":
                self.plain_text += "\t" + code + "\t" + operands[0] + ", " +\
                    operands[1] + "\n"

            elif code == "label":
                self.plain_text += operands[0] + ":\n"

            elif code == "CALL":
                if operands[0] == "print":
                    self.plain_text += "\t" + code + "\tprintf\n"
                elif operands[0] == "scan":
                    self.plain_text += "\t" + code + "\tscanf\n"

            elif code == "PUSH" or code == "POP":
                self.plain_text += "\t" + code + "\t" + operands[0] + "\n"

            elif code == "JNL" or code == "JL" or code == "JMP":
                self.plain_text += "\t" + code + "\t" + operands[0] + "\n"

            elif  code == "CMP":
                self.plain_text +=\
                    "\t" + code + "\t" + operands[0] + ", " + operands[1] + "\n"

            elif code == "SUB" or code == "IMUL" or code == "IDIV":
                self.plain_text += \
                    "\t" + code + "\t" + operands[0] + ", " + operands[1] + "\n"
        self.code_tail()

    def compile(self):
        self.plain_text = ""
        self.add_header()
        self.add_format()
        self.generate_code()
        self.generate_declarations()

        return self.plain_text
